package com.opencassandra.descfile;

import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.regex.Pattern;

import net.sf.json.JSONArray;
import net.sf.json.JSONObject;

import org.apache.commons.io.FileUtils;

import com.csvreader.CsvReader;
import com.mysql.jdbc.exceptions.MySQLSyntaxErrorException;
import com.opencassandra.v01.dao.impl.InsertMysqlByDataToZD;
import com.opencassandra.v01.dao.impl.InsertMysqlDao;

/**
 * 终端文件解析程序
 * 
 * @author：kxc
 * @date：Oct 23, 2015
 */
public class DescFile {
	String root = "c:\\Orgnize\\";
	boolean isChange = false;

	static Map map = new HashMap();
	Map timeMap = new HashMap();
	static int mapCount = 0;
	static int length = 0;
	int counts = 0;
	int errors = 0;
	public static int count = 0;
	private InsertMysqlDao insertMysqlDao = new InsertMysqlDao();
	private List appid = new ArrayList();
	private static String pathType = ConfParser.pathType;
	private static String ak = ConfParser.ak;
	// String[] spth = { "ping", "http" };
	// 获取配置文件中配置的需遍历的文件夹名
	private static String[] spth = ConfParser.folder;
	// 截取报告入库时间的rex
	private static Pattern pattern1 = Pattern.compile("[-]");
	private static Pattern pattern2 = Pattern.compile("[_]");
	// 获取配置文件中的须解析的时间
	private static String[] testdate = ConfParser.testdate;
	// 获取配置文件中的临时表
	private static String temptable = ConfParser.temptable;

	synchronized public static void setCount() {
		DescFile.count++;
	}

	public static int successCount = 0;
	public static int failCount = 0;
	private ExecutorService analyzeThreadPool;
	// 数据库连接
	Statement statement;
	Connection conn;

	/**
	 * 终端执行文件
	 * 
	 * @param args
	 * @return void
	 */
	static public void main(String[] args) {
		InsertMysqlDao insertMysqlDao = new InsertMysqlDao();
		InsertMysqlByDataToZD insertMysqlByDataToZD = new InsertMysqlByDataToZD();
		DescFile desc = new DescFile();
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		String dateString = dateFormat.format(new Date());
		System.out.println(dateString + ">>> Start!");
		desc.setChange(true);
		// 获取appid
		desc.appid = desc.getAppids();
		String file[] = new String[] {};
		file = ConfParser.srcReportPath;// C:\Users\test
										// 该路径为appid的上层路径（也就是总的文件目录）
		// 获取配置文件中code的值（1052,0153。。）
		String code1 = (ConfParser.code != null && ConfParser.code.length > 0) ? ConfParser.code[0] : "";
		if ("all".equals(code1)) {
		} else {
			if (pathType.equals("default")) {
				for (int k = 0; k < testdate.length; k++) {
					String date = testdate[k];
					for (int i = 0; i < file.length; i++) {
						String filePath = file[i];
						System.out.println(filePath);
						String org = "";
						String filePathOrg = "";
						if (filePath.endsWith("Default")) {
							filePathOrg = filePath.replace(File.separator + "Default", "");
						}
						if (filePathOrg.contains(File.separator)) {
							org = filePathOrg.substring(filePathOrg.lastIndexOf(File.separator) + 1, filePathOrg.length());
						} else {
							continue;
						}
						desc.findFile(filePath, org, date);
					}
				}
			} else {
				for (int k = 0; k < testdate.length; k++) {
					String date = testdate[k];
					for (int i = 0; i < file.length; i++) {
						String filePath = file[i];
						System.out.println(filePath);
						String org = "";
						while (filePath.endsWith(File.separator)) {
							filePath = filePath.substring(0, filePath.length() - 1);
						}
						org = filePath.substring(filePath.lastIndexOf(File.separator) + 1, filePath.length());
						desc.findFile(filePath, org, date);
					}
				}
			}

		}

		GetPostTest getPostTest = new GetPostTest();
		String codeUrl = ConfParser.getCodePath;
		if (codeUrl.isEmpty()) {

			if (pathType.equals("default")) {
				String[] paths = getPostTest.getPathsDefault(desc.appid);
				for (int j = 0; j < spth.length; j++) {
					String string = spth[j];
					for (int k = 0; k < testdate.length; k++) {
						String date = testdate[k];
						for (int i = paths.length - 1; i >= 0; i--) {
							String filePath = paths[i];
							if (filePath == null || filePath.isEmpty()) {
								continue;
							}
							System.out.println(filePath);
							String org = "";
							String filePathOrg = "";
							if (filePath.endsWith("Default")) {
								filePathOrg = filePath.replace(File.separator + "Default", "");
							}
							if (filePathOrg.contains(File.separator)) {
								org = filePathOrg.substring(filePathOrg.lastIndexOf(File.separator) + 1, filePathOrg.length());
							}
							filePath = filePath + File.separator + string;
							desc.findFile(filePath, org, date);
						}
					}
				}
			} else {
				String[] paths = getPostTest.getPaths(desc.appid);
				for (int k = 0; k < testdate.length; k++) {
					String date = testdate[k];
					for (int i = paths.length - 1; i >= 0; i--) {
						String filePath = paths[i];
						if (filePath == null || filePath.isEmpty()) {
							continue;
						}
						System.out.println(filePath);
						String org = "";
						while (filePath.endsWith(File.separator)) {
							filePath = filePath.substring(0, filePath.length() - 1);
						}
						org = filePath.substring(filePath.lastIndexOf(File.separator) + 1, filePath.length());
						desc.findFile(filePath, org, date);
					}
				}
			}

		} else {
			if (pathType.equals("default")) {
				/**
				 * 带Default的解析路径获取
				 */
				String dbName = "";
				for (int j = 0; j < ConfParser.code.length; j++) {
					ArrayList keyList = new ArrayList();
					String code2 = ConfParser.code[j];
					String codeStr = "code=" + code2;
					System.out.println(ConfParser.url);
					if (!ConfParser.url.endsWith("/")) {
						System.out.println(ConfParser.url);
						if (j > 0) {
							if (ConfParser.url.contains("_" + ConfParser.code[j - 1])) {
								ConfParser.url = ConfParser.url.replace("_" + ConfParser.code[j - 1], "");
							}
						}
						dbName = ConfParser.url.substring(ConfParser.url.lastIndexOf("/") + 1, ConfParser.url.length());
						dbName = dbName + "_" + code2;
						ConfParser.url = ConfParser.url + "_" + code2;
						System.out.println(ConfParser.url);
					} else {
						System.out.println(ConfParser.url);
						dbName = "testdataanalyse";
						ConfParser.url = ConfParser.url + "testdataanalyse";
						System.out.println(ConfParser.url);
					}
					System.out.println(ConfParser.url);
					try {
						insertMysqlDao.start();
					} catch (MySQLSyntaxErrorException e) {
						insertMysqlDao.createDB(dbName);
						try {
							insertMysqlDao.start();
						} catch (Exception e1) {
							e1.printStackTrace();
						}
					} catch (Exception e) {
						e.printStackTrace();
					}
					try {
						insertMysqlDao.close();
					} catch (SQLException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					if (code2.equals("all")) {
						ConfParser.csvwritepath = ConfParser.csvwritepath.substring(0, ConfParser.csvwritepath.lastIndexOf(File.separator) + 1) + code2;
						String paths = "";
						if (ConfParser.org_prefix != null && !ConfParser.org_prefix.isEmpty()) {
							paths = ConfParser.org_prefix;
						} else {
							if (ConfParser.srcReportPath != null && ConfParser.srcReportPath.length > 0 && ConfParser.srcReportPath[0] != null) {
								paths = ConfParser.srcReportPath[0];
							}
						}
						File filePaths = new File(paths);
						File files[] = filePaths.listFiles(new FilenameFilter() {
							public boolean accept(File dir, String name) {
								if (dir.isDirectory()) {
									return true;
								}
								return false;
							}
						});
						for (int k = 0; k < testdate.length; k++) {
							String date = testdate[k];
							for (int i = 0; i < files.length; i++) {
								File rootFile = files[i];
								String rootFileOrg = rootFile.getAbsolutePath().replace(ConfParser.org_prefix, "");
								if (rootFileOrg.endsWith(File.separator)) {
									rootFileOrg = rootFileOrg.substring(0, rootFileOrg.lastIndexOf(File.separator));
								}
								desc.findFile(rootFile.getAbsolutePath(), rootFileOrg, date);
							}
						}
					} else {
						String sr = GetPostTest.sendGet(codeUrl, codeStr);
						System.out.println(sr);
						JSONObject json = JSONObject.fromObject(sr);
						try {
							JSONObject thisOrgInfo = json.getJSONObject("thisOrgInfo");
							String keySelf = thisOrgInfo.getString("key");
							String storePathSelf = thisOrgInfo.getString("storepath");
							if (keySelf == null) {
								keySelf = "";
							}
							if (!keySelf.isEmpty()) {
								keyList.add(keySelf);
							}
							if (storePathSelf != null && !storePathSelf.isEmpty()) {
								storePathSelf = storePathSelf.replace("/", File.separator).replace("\\", File.separator);
								if (storePathSelf.endsWith("Default")) {
									storePathSelf = storePathSelf.replace(File.separator + "Default", "");
								}
								keyList.add(storePathSelf);
							}
						} catch (Exception e) {
							e.printStackTrace();
							continue;
						}

						for (int m = 0; m < spth.length; m++) {
							String string = spth[m];
							for (int k = 0; k < testdate.length; k++) {
								String date = testdate[k];
								String[] paths = getPostTest.getPaths(desc.appid, keyList);
								for (int i = paths.length - 1; i >= 0; i--) {
									String filePath = paths[i];
									if (filePath == null || filePath.isEmpty()) {
										continue;
									}
									System.out.println(filePath);
									String org = "";
									String filePathOrg = "";
									if (filePath.endsWith("Default")) {
										filePathOrg = filePath.replace(File.separator + "Default", "");
									}
									if (filePathOrg.contains(File.separator)) {
										org = filePathOrg.substring(filePathOrg.lastIndexOf(File.separator) + 1, filePathOrg.length());
									}
									filePath = filePath + File.separator + string;
									desc.findFile(filePath, org, date);
								}
							}
						}
					}
					insertMysqlByDataToZD.queryAndCreat();
					System.out.println(ConfParser.url + "_" + code2+" 临时表中数据更新-----》》正式表中---执行完毕。。。。。。。。。。。。。");

				}
			} else {
				/**
				 * 不带Default的解析路径获取
				 */
				if (code1.equals("all")) {
					String dbName = "";
					if (!ConfParser.url.endsWith("/")) {
						System.out.println(ConfParser.url);
						dbName = ConfParser.url.substring(ConfParser.url.lastIndexOf("/") + 1, ConfParser.url.length());
						dbName = dbName + "_" + code1;
						ConfParser.url = ConfParser.url + "_" + code1;
						System.out.println(ConfParser.url);
					} else {
						System.out.println(ConfParser.url);
						dbName = "testdataanalyse";
						ConfParser.url = ConfParser.url + "testdataanalyse";
						System.out.println(ConfParser.url);
					}
					System.out.println(ConfParser.url);
					try {
						insertMysqlDao.start();
					} catch (MySQLSyntaxErrorException e) {
						insertMysqlDao.createDB(dbName);
						try {
							insertMysqlDao.start();
						} catch (Exception e1) {
							e1.printStackTrace();
						}
					} catch (Exception e) {
						e.printStackTrace();
					}
					try {
						insertMysqlDao.close();
					} catch (SQLException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					ConfParser.csvwritepath = ConfParser.csvwritepath.substring(0, ConfParser.csvwritepath.lastIndexOf(File.separator) + 1) + code1;
					String paths = "";
					if (ConfParser.org_prefix != null && !ConfParser.org_prefix.isEmpty()) {
						paths = ConfParser.org_prefix;
					} else {
						if (ConfParser.srcReportPath != null && ConfParser.srcReportPath.length > 0 && ConfParser.srcReportPath[0] != null) {
							paths = ConfParser.srcReportPath[0];
						}
					}
					File filePaths = new File(paths);
					File files[] = filePaths.listFiles(new FilenameFilter() {
						public boolean accept(File dir, String name) {
							if (dir.isDirectory()) {
								return true;
							}
							return false;
						}
					});
					for (int k = 0; k < testdate.length; k++) {
						String date = testdate[k];
						for (int i = 0; i < files.length; i++) {
							File rootFile = files[i];
							String rootFileOrg = rootFile.getAbsolutePath().replace(ConfParser.org_prefix, "");
							if (rootFileOrg.endsWith(File.separator)) {
								rootFileOrg = rootFileOrg.substring(0, rootFileOrg.lastIndexOf(File.separator));
							}
							desc.findFile(rootFile.getAbsolutePath(), rootFileOrg, date);
						}
					}
				} else {
					String dbName = "";
					for (int j = 0; j < ConfParser.code.length; j++) {
						ArrayList keyList = new ArrayList();
						String code2 = ConfParser.code[j];
						String codeStr = "code=" + code2;
						System.out.println(ConfParser.url);
						ConfParser.csvwritepath = ConfParser.csvwritepath.substring(0, ConfParser.csvwritepath.lastIndexOf(File.separator) + 1) + code2;
						if (!ConfParser.url.endsWith("/")) {
							System.out.println(ConfParser.url);
							if (j > 0) {
								if (ConfParser.url.contains("_" + ConfParser.code[j - 1])) {
									ConfParser.url = ConfParser.url.replace("_" + ConfParser.code[j - 1], "");
								}
							}
							dbName = ConfParser.url.substring(ConfParser.url.lastIndexOf("/") + 1, ConfParser.url.length());
							// dbName = dbName + "_" + code2;
							// ConfParser.url = ConfParser.url + "_" + code2;
							System.out.println(dbName);
						} else {
							System.out.println(ConfParser.url);
							dbName = "testdataanalyse";
							ConfParser.url = ConfParser.url + "testdataanalyse";
							System.out.println(ConfParser.url);
						}
						System.out.println(ConfParser.url);
						try {
							insertMysqlDao.start();
						} catch (MySQLSyntaxErrorException e) {
							insertMysqlDao.createDB(dbName);
							try {
								insertMysqlDao.start();
							} catch (Exception e1) {
								e1.printStackTrace();
							}
						} catch (Exception e) {
							e.printStackTrace();
						}
						try {
							insertMysqlDao.close();
						} catch (SQLException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}

						String sr = GetPostTest.sendGet(codeUrl, codeStr);
						System.out.println(sr);
						JSONObject json = JSONObject.fromObject(sr);
						try {
							JSONObject thisOrgInfo = json.getJSONObject("thisOrgInfo");
							JSONArray jsonArray = json.getJSONArray("detail").isArray() ? json.getJSONArray("detail") : new JSONArray();
							String keySelf = thisOrgInfo.getString("key");
							String storePathSelf = thisOrgInfo.getString("storepath");

							if (keySelf == null) {
								keySelf = "";
							}
							if (!keySelf.isEmpty()) {
								keyList.add(keySelf);
							}
							if (storePathSelf != null && !storePathSelf.isEmpty()) {
								storePathSelf = storePathSelf.replace("/", File.separator).replace("\\", File.separator);
								if (storePathSelf.endsWith("Default")) {
									storePathSelf = storePathSelf.replace(File.separator + "Default", "");
								}
								keyList.add(storePathSelf);
							}
							for (int i = 0; i < jsonArray.size(); i++) {
								JSONObject jsonObject = jsonArray.getJSONObject(i);
								String key = jsonObject.getString("key") == null ? "" : jsonObject.getString("key");
								String storePath = jsonObject.getString("storepath");
								if (!key.isEmpty()) {
									keyList.add(key);
								}
								if (storePath != null && !storePath.isEmpty()) {
									storePath = storePath.replace("/", File.separator).replace("\\", File.separator);
									if (storePath.endsWith("Default")) {
										storePath = storePath.replace(File.separator + "Default", "");
									}
									keyList.add(storePath);
								}
							}
						} catch (Exception e) {
							e.printStackTrace();
							continue;
						}
						String paths[] = getPostTest.getPaths(desc.appid, keyList);
						for (int k = 0; k < testdate.length; k++) {
							String date = testdate[k];
							for (int i = 0; i < paths.length; i++) {
								String filePath = paths[i];
								if (filePath == null || filePath.isEmpty()) {
									continue;
								}
								System.out.println(filePath);
								String org = "";
								while (filePath.endsWith(File.separator)) {
									filePath = filePath.substring(0, filePath.length() - 1);
								}
								org = filePath.substring(filePath.lastIndexOf(File.separator) + 1, filePath.length());
								desc.findFile(filePath, org, date);
							}
						}
						insertMysqlByDataToZD.queryAndCreat();
						System.out.println(ConfParser.url + "_" + code2+" :临时表中数据更新-----》》正式表中---执行完毕。。。。。。。。。。。。。");
					}
				}
			}

		}
		System.out.println("counts: " + desc.counts / testdate.length);
		System.out.println("successCount: " + successCount / testdate.length);
		System.out.println("failCount: " + failCount / testdate.length);
		desc.getAnalyzeThreadPool().shutdown();
		dateString = dateFormat.format(new Date());
		System.out.println(dateString + ">>>报告解析 End!");
	}

	/**
	 * 连接数据库获取对应的appid，用于路径的拼接
	 * 
	 * @return
	 * @return List
	 */
	public List getAppids() {
		List appids = new ArrayList();
		String[] appnames = ConfParser.appname;
		boolean flag = false;
		String names = "";
		if (appnames != null && appnames.length > 0) {
			names = "(";
			for (int i = 0; i < appnames.length; i++) {
				String appname = appnames[i];
				System.out.println(appname+":::::::::::");
				if (appname.equals("OTS APP 1.5系列") || appname.equals("OTS 1.5 for Android")) {
					flag = true;
					continue;
				} else {
					if (!appname.isEmpty()) {
						names += "'" + appname + "',";
					}
				}
			}
			while (names.endsWith(",")) {
				names = names.substring(0, names.length() - 1);
			}
			names += ")";
		}
		String sql = "";
		if (names.isEmpty() || names.equals("()")) {
			if (flag) {
				appids.add("default_app_id");
			}
			return appids;
		} else {
			sql = "SELECT app_id FROM static_param.b_appid_info where app_name_ch in " + names + " or app_name_en in " + names + ";";
			appids = insertMysqlDao.getappIds(sql);
			if (flag) {
				appids.add("default_app_id");
			}
			return appids;
		}
	}

	/**
	 * 文件遍历
	 * 
	 * @param rootDirectory
	 * @param org
	 * @return void
	 */
	public void findFile(String rootDirectory, String org, String date) {
		System.out.println("开始findFile************：" + new Date().toLocaleString() + "   毫秒：" + new Date().getTime());

		File rootFile = new File(rootDirectory);
		if (!rootFile.exists()) {
			// rootFile.mkdir();
			return;
		}
		File[] fileList = rootFile.listFiles(new FilenameFilter() {
			public boolean accept(File dir, String name) {
				if (dir.isDirectory() || name.indexOf(".summary.csv") >= 0 || name.indexOf(".abstract.csv") >= 0) {
					return true;
				}
				return false;
			}
		});
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		String dateString = dateFormat.format(new Date());
		StringBuffer errStr = new StringBuffer();
		try {
			for (int i = 0; i < fileList.length; i++) {
				File myFile = fileList[i];
				if (myFile.isDirectory()) {
					length = length + myFile.listFiles().length;
					findFile(myFile.getAbsolutePath(), org, date);
				}
				try {
					try {
						this.deal(myFile, 01001, org, date);
					} catch (Exception e) {
						e.printStackTrace();
						errStr.append(myFile.getAbsolutePath() + ":\r\n");
						errStr.append(e.toString() + "\r\n");
						errors++;
						System.out.println("文件处理异常>>>" + Paths.get(myFile.getAbsolutePath()));
						System.out.println("异常报告数为>>>" + errors);
					}
					counts++;
					if ((counts % 100) == 0) {
						System.out.println("已处理报告数为：" + length);
					}
				} catch (Exception e) {
					e.printStackTrace();
					errStr.append(myFile.getAbsolutePath() + ":\r\n");
					errStr.append(e.getMessage() + "\r\n");
				}
			}
			System.out.println(dateString + ">>> 发现待处理文件数量为： " + length);
		} catch (Exception e1) {
			e1.printStackTrace();
		}
	}

	InsertMysqlByDataToZD insertMysqlByDataToZD = new InsertMysqlByDataToZD();

	/**
	 * 把遍历出的文件根据时间进行数据入库
	 * 
	 * @param file
	 * @param ServiceId
	 * @param org
	 * @return void
	 */
	public void deal(File file, int ServiceId, String org, String date) {
		if (file.getAbsoluteFile().toString().endsWith(".abstract.csv") || file.getAbsoluteFile().toString().endsWith(".summary.csv")) {
			System.out.println("开始deal************：" + new Date().toLocaleString() + "   毫秒：" + new Date().getTime());

			String imei = file.getParentFile().getName();
			String filePath = file.getName();

			String numStrs[] = pattern1.split(filePath);
			String ss = numStrs[1];
			String Tm[] = pattern2.split(ss);
			String testtime = Tm[0] + Tm[1];// 测试报告时间

			System.out.println(date + ":::::::::");
			if ((!date.isEmpty() && date.equals(testtime)) || date.isEmpty()) {
				System.out.println("appendSql 处理经纬度 日期等 END  查询数据库表是否存在开始 -----------------：" + new Date().toLocaleString());
				boolean tableFlag = insertMysqlByDataToZD.queryTableExist(temptable);
				System.out.println("appendsql  查询数据库表是否存在 END -------------------：" + new Date().toLocaleString());
				if (!tableFlag) {
					System.out.println("appendsql 创建表Start--------------：" + new Date().toLocaleString());
					insertMysqlByDataToZD.createTab(temptable);
					System.out.println("appendsql 创建表END--------------：" + new Date().toLocaleString());
				}
				// 查询该imei在testtime的月份是否已经存在
				boolean fa = insertMysqlByDataToZD.queryExist(temptable, testtime, imei);// 有数据则为true
				System.out.println(fa + "  ::::查询数据是否存在：：：：：");
				if (!fa) {
					splitAbstractCsv(file, 01001, org);
					setCount();
				} else {
					return;
				}
			} else {
				return;
			}
		}
	}

	/**
	 * 
	 * @param filePath
	 *            要解析的文件
	 * @param ServiceId
	 * @param org
	 * @return
	 * @return boolean
	 */
	public boolean splitAbstractCsv(File filePath, int ServiceId, String org) {
		System.out.println("开始splitAbstractCsv************：" + new Date().toLocaleString() + "   毫秒：" + new Date().getTime());
		StringBuffer errStr1 = new StringBuffer("");
		try {
			ArrayList<String[]> absHeader = new ArrayList<String[]>();
			ArrayList<String[]> absBody = new ArrayList<String[]>();
			ArrayList<String[]> testScenario = new ArrayList<String[]>();
			ArrayList<String[]> csvList = this.readCsv(filePath);
			int dataEreaIndex = 0;
			if (ServiceId == 03001) {
				for (int i = 0; i < csvList.size(); i++) {
					if (csvList.get(i) != null && !isBlankLine(csvList.get(i))) {
						if (csvList.get(i)[0] != null) {
							if (csvList.get(i)[0].equals("测试时间") || csvList.get(i)[0].equals("测速类型")) {
								dataEreaIndex = 1;
							} else if (csvList.get(i)[0].equals("--- Test Scenario ---")) {
								dataEreaIndex = 2;
							}
						}
						if (dataEreaIndex == 0) {
							absHeader.add(csvList.get(i));
						} else if (dataEreaIndex == 1) {
							absBody.add(csvList.get(i));
						} else if (dataEreaIndex == 2) {
							testScenario.add(csvList.get(i));
						}
					} else {
						dataEreaIndex++;
					}
				}
			} else if (ServiceId == 01001) {
				if (csvList == null || csvList.size() == 0) {
					return false;
				}
				for (int i = 0; i < csvList.size(); i++) {
					if (csvList.get(i) != null && !isBlankLine(csvList.get(i))) {
						if (csvList.get(i)[0] != null) {
							if ((csvList.get(i)[0].equals("测试时间") || csvList.get(i)[0].trim().toLowerCase().equals("time") || csvList.get(i)[0].trim().toLowerCase().equals("test time"))
									&& csvList.size() > i + 1
									&& csvList.get(i + 1) != null
									&& csvList.get(i + 1).length >= 2
									&& csvList.get(i + 1)[0] != null
									&& (csvList.get(i + 1)[0].contains("型号") || (csvList.get(i + 1)[0].trim().toLowerCase().contains("device type")
											|| csvList.get(i + 1)[0].trim().toLowerCase().contains("terminal type") || csvList.get(i + 1)[0].trim().toLowerCase().contains("terminal mode")
											|| csvList.get(i + 1)[0].trim().toLowerCase().contains("device model") || csvList.get(i + 1)[0].trim().toLowerCase().contains("terminal model")))) {

							} else if ((csvList.get(i)[0].equals("测试时间") || csvList.get(i)[0].equals("测试开始时间") || csvList.get(i)[0].equals("时间")
									|| (csvList.get(i)[0].equals("测速类型") || csvList.get(i)[0].equals("测试类型")) || csvList.get(i)[0].equals("网络制式1时间") || csvList.get(i)[0].equals("网络(1)时间")
									|| csvList.get(i)[0].equals("Network 1Time") || csvList.get(i)[0].equals("Network(1) Time") || csvList.get(i)[0].trim().toLowerCase().equals("time")
									|| csvList.get(i)[0].trim().toLowerCase().equals("duration") || csvList.get(i)[0].trim().toLowerCase().equals("start time")
									|| csvList.get(i)[0].trim().toLowerCase().equals("test start time") || (csvList.get(i)[0].trim().toLowerCase().equals("time") && (csvList.get(i)[1] != null
									&& csvList.get(i)[1].trim().toLowerCase().equals("network") || csvList.get(i)[1].trim().toLowerCase().equals("website") || csvList.get(i)[1].trim().toLowerCase()
									.equals("address"))))
									&& csvList.get(i).length > 2 && csvList.get(i)[2] != null && !csvList.get(i)[2].equals("")) {
								dataEreaIndex = 1;
							} else if (csvList.get(i)[0].contains("Test Scenario")) {
								dataEreaIndex = 2;
							}
						}
						if (dataEreaIndex == 0) {
							absHeader.add(csvList.get(i));
						} else if (dataEreaIndex == 1) {
							absBody.add(csvList.get(i));
						} else if (dataEreaIndex == 2) {
							testScenario.add(csvList.get(i));
						}
					} else {
					}
				}
			}
			this.writeToFile(absHeader, absBody, testScenario, filePath, org);
		} catch (Exception e) {
			errStr1.append(filePath.getAbsolutePath() + ":\r\n");
			errStr1.append(e.toString() + "\r\n");
			e.printStackTrace();
		}
		return true;
	}

	/**
	 * 把解析文件获取到的数据进行再次的整理成可入库的map
	 * 
	 * @param absHeader
	 * @param absBody
	 * @param testScenario
	 * @param filePath
	 * @param org
	 * @return void
	 */
	private void writeToFile(ArrayList<String[]> absHeader, ArrayList<String[]> absBody, ArrayList<String[]> testScenario, File filePath, String org) {
		System.out.println("开始writeToFile************：" + new Date().toLocaleString() + "   毫秒：" + new Date().getTime());
		StringBuffer errStr2 = new StringBuffer("");
		// 获取测试报告时间
		String numStrs[] = pattern1.split(filePath.getName());
		String ss = numStrs[1];
		String Tm[] = pattern2.split(ss);
		String testtime = Tm[0] + Tm[1];// 测试报告时间

		// 要生成的TXT的文件内容
		StringBuffer str = new StringBuffer();
		// 头部Map
		Map absHeaderMap = new HashMap();
		// 主体Map
		Map absBodyMap = new HashMap();
		// testScenario Map
		Map testScenarioMap = new HashMap();
		try {
			for (int i = 0; i < absHeader.size(); i++) {
				String key = absHeader.get(i)[0];
				try {
					String value = "";
					if (absHeader.get(i).length >= 2) {
						value = absHeader.get(i)[1];
					}
					absHeaderMap.put(key, value);
				} catch (ArrayIndexOutOfBoundsException e) {
					absHeaderMap.put(key, "");
					errStr2.append(filePath.getAbsolutePath() + ":\r\n");
					errStr2.append(e.toString() + "\r\n");
					e.printStackTrace();
				} catch (Exception e) {
					absHeaderMap.put(key, "");
					errStr2.append(filePath.getAbsolutePath() + ":\r\n");
					errStr2.append(e.toString() + "\r\n");
					e.printStackTrace();
				}
			}
			for (int i = 0; i < testScenario.size(); i++) {
				String key = testScenario.get(i)[0];
				try {
					if (key != null) {
						String value = "";
						if (i != 0) {
							if (testScenario.get(i).length >= 2) {
								value = testScenario.get(i)[1];
							}
						}
						if (key.equals("") && testScenario.get(i + 1).length >= 2 && testScenario.get(i + 1)[0] != null) {
							testScenarioMap.put(key, value);
						} else if (!key.equals("")) {
							testScenarioMap.put(key, value);
						}
					}

				} catch (ArrayIndexOutOfBoundsException e) {
					testScenarioMap.put(key, "");
					errStr2.append(filePath.getAbsolutePath() + ":\r\n");
					errStr2.append(e.toString() + "\r\n");
					e.printStackTrace();
				} catch (Exception e) {
					testScenarioMap.put(key, "");
					errStr2.append(filePath.getAbsolutePath() + ":\r\n");
					errStr2.append(e.toString() + "\r\n");
					e.printStackTrace();
				}
			}
			if (absBody != null && absBody.size() > 0) {
				String[] key = absBody.get(0);// 主体的表头
				if (key != null) {
					for (int i = 1; i < absBody.size(); i++) {// 主体的数据
						try { // 第i排数据，i从1开始
							String[] value = absBody.get(i);
							if (!isBlankLine(value)) {
								Map map = new HashMap();
								for (int j = 0; j < key.length; j++) {
									String sonKey = key[j];
									String sonValue = "";
									try {
										sonValue = value[j];
									} catch (Exception e) {
										sonValue = "";
									}
									map.put(sonKey, sonValue);
								}
									
								if ((map.containsKey("GPS信息") || map.containsKey("GPS位置信息") || map.containsKey("GPS位置") || map.containsKey("测试位置") || map.containsKey("测试GPS位置"))
										&& (map.get("GPS信息") != null || map.get("GPS位置信息") != null || map.get("GPS位置") != null || map.get("测试位置") != null || map.get("测试GPS位置") != null)
										) {
									if(map.containsValue("0.000000E 0.000000N")||map.containsValue("(null) (null)")){
										continue;
									}else{
										absBodyMap.put(1, map);
										break;
									}
								}
							}
						} catch (ArrayIndexOutOfBoundsException e) {
							absBodyMap.put(key, "");
							errStr2.append(filePath.getAbsolutePath() + ":\r\n");
							errStr2.append(e.toString() + "\r\n");
							e.printStackTrace();
						} catch (Exception e) {
							absBodyMap.put(key, "");
							errStr2.append(filePath.getAbsolutePath() + ":\r\n");
							errStr2.append(e.toString() + "\r\n");
							e.printStackTrace();
						}
					}
				}
			}
		} catch (Exception e) {
			errStr2.append(filePath.getAbsolutePath() + ":\r\n");
			errStr2.append(e.toString() + "\r\n");
			e.printStackTrace();
		}
		try {
			System.out.println("keyspace:" + org);
			String imei = filePath.getParentFile().getName();
			setMapData(absHeaderMap, absBodyMap, testScenarioMap, testtime, imei);

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * 整理数据
	 * 
	 * @param headerMap
	 * @param bodyMap
	 * @param testScenrioMap
	 * @param testtime
	 * @param imei
	 * @return void
	 */
	private void setMapData(Map headerMap, Map bodyMap, Map testScenrioMap, String testtime, String imei) {

		System.out.println("开始第一步SetMapData************：" + new Date().toLocaleString() + "   毫秒：" + new Date().getTime());
		Map allMap = new HashMap();
		// allMap.put("imsi", imsi);
		String detailreport = "";

		InsertMysqlByDataToZD insertMysqlByDataToZD = new InsertMysqlByDataToZD();
		// 获取detailreport
		String destFilePath = ConfParser.backReportPath;
		// 处理数据
		if (bodyMap != null) {
			if (bodyMap.size() == 1) {
				Map bodyNextMap = (Map) bodyMap.get(1);
				allMap.put("appid", appid);
				allMap.put("testtime", testtime);
				allMap.put("imei", imei);
				allMap = setMapData(headerMap, allMap);
				allMap = setMapData(testScenrioMap, allMap);
				allMap = setMapData(bodyNextMap, allMap);
				insertMysqlByDataToZD.insertZDdata(allMap, testtime, imei);
			} else {
				allMap = setMapData(headerMap, allMap);
				allMap = setMapData(testScenrioMap, allMap);
				allMap.put("appid", appid);
				allMap.put("testtime", testtime);
				allMap.put("imei", imei);
				insertMysqlByDataToZD.insertZDdata(allMap, testtime, imei);
			}
		} else {
			allMap.put("appid", appid);
			allMap.put("testtime", testtime);
			allMap.put("imei", imei);
			insertMysqlByDataToZD.insertZDdata(allMap, testtime, imei);
		}
	}

	/**
	 * 把传进来的数据放进一个map中
	 * 
	 * @param DataMap
	 * @param allMap
	 * @return
	 * @return Map
	 */
	private Map setMapData(Map DataMap, Map allMap) {
		Set set = DataMap.keySet();
		Iterator iter = set.iterator();
		while (iter.hasNext()) {
			String key = (String) iter.next();
			String value = "";
			if (key == null || key.isEmpty()) {
				key = "";
			}
			try {
				value = (String) DataMap.get(key);
			} catch (Exception e) {
			}
			allMap.put(key, value);
		}
		return allMap;
	}

	public String subTxt(String str) {
		if (str.startsWith("{")) {
			str = str.substring(1, str.length());
		}
		if (str.endsWith("}")) {
			str = str.substring(0, str.length() - 1);
		}
		return str;
	}

	/**
	 * 读取CSV文件
	 * 
	 * @param filePath
	 * @return ArrayList<String[]>
	 */
	public ArrayList<String[]> readCsv(File filePath) {
		ArrayList<String[]> csvList = null;
		try {
			csvList = new ArrayList<String[]>(); // 用来保存数据
			String csvFilePath = filePath.getAbsolutePath();
			CsvReader reader = new CsvReader(csvFilePath, ',', Charset.forName("GB2312")); // 一般用这编码读就可以了
			// reader.readHeaders(); // 跳过表头 如果需要表头的话，不要写这句。
			while (reader.readRecord()) { // 逐行读入除表头的数据
				String[] values = null;
				values = reader.getValues();
				csvList.add(values);
			}
			reader.close();

		} catch (Exception ex) {
			ex.printStackTrace();
		}
		return csvList;
	}

	/**
	 * 判断CSV文件中某一行是不是空行
	 * 
	 * @param values
	 * @return
	 */
	public boolean isBlankLine(String[] values) {
		boolean isBlank = true;
		if (values != null) {
			for (int i = 0; i < values.length; i++) {
				if (values[i] != null && !"".equals(values[i])) {
					isBlank = false;
				}
			}
		}
		return isBlank;
	}

	// ------------------------------------------set、get方法------------------------------------------------
	public ExecutorService getAnalyzeThreadPool() {
		return analyzeThreadPool;
	}

	public void setAnalyzeThreadPool(ExecutorService analyzeThreadPool) {
		this.analyzeThreadPool = analyzeThreadPool;
	}

	public void setCounts(int counts) {
		this.counts = counts;
	}

	public int getCounts() {
		return counts;
	}

	public boolean isChange() {
		return isChange;
	}

	public void setChange(boolean isChange) {
		this.isChange = isChange;
	}

	public DescFile() {
		super();
		analyzeThreadPool = Executors.newFixedThreadPool(1280);
	}

	public DescFile(String root) {
		super();
		this.root = root;
		analyzeThreadPool = Executors.newFixedThreadPool(1280);
	}

	public static int getCount() {
		return count;
	}
}
